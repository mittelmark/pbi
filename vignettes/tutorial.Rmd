---
title: Vignette for the pbi package
author: Detlef Groth, University of Potsdam, Germany
date: 2024-03-11 18:00
output: 
    rmarkdown::html_vignette:
        toc: true
vignette: >
  %\VignetteIndexEntry{Vignette for the pbi package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
include-before: |
    <style> 
    body { max-width: 1000px; font-family: Candara, sans-serif;} 
    table { min-width: 400px; border-spacing: 5px;  border-collapse: collapse; }
    </style>
    
---

## Introduction

The _pbi_ package  contains  functions  and data used in the course  Practical
Bioinformatics  at the University of Potsdam. The course is a mandatory course
in the Master  Biochemistry  and Molecular  Biology  taking place every Summer
semester. 

All package functions are prefixed with a *pbi_* prefix and are as well stored
within  a  environment,  called  _pbi_.  You  can  see  the  methods  of  this
environment/object using the _ls_ function of R. Like so:


```{r}
library(pbi)
ls(pbi)
```

Some of the functions will be now explained a little bit in more detail sorted by their purpose.

## Statistical Functions

For effect size functions see below.

### Clustering functions

- pbi$clusterSilhouette - clustering strength
- pbi$clusterSimIndex - compare two clusterings

```{r}
### clustering strength
D=dist(scale(iris[,1:4]))
hcl=hclust(D)
pbi_clusterSilhouette(cutree(hcl,2),D)
pbi_clusterSilhouette(cutree(hcl,3),D)$avg.width
pbi_clusterSilhouette(cutree(hcl,4),D)$avg.width
pbi_clusterSilhouette(cutree(hcl,5),D)$avg.width
### -> three cluster seems to be the best
### compare two clusterings
set.seed(123)
hcl1=hclust(dist(iris[,1:4]))
hcl2=hclust(dist(scale(iris[,1:4])))
round(unlist(pbi_clusterSimIndex(cutree(hcl1,3),
    cutree(hcl2,3))),2)
```

### pbi$cv -  coefficient of variation

```{r}
pbi_cv(rnorm(20,mean=100,sd=4))
pbi_cv(c(1,2,3,4))
pbi_cv(c(1,2,3,4,NA))
pbi_cv(c(1,2,3,4,NA),na.rm=TRUE)
```

### pbi$dcorr - pairwise correlations

```{r}
options(width=90)
data(swiss)
lapply(pbi_dcorr(swiss)[1:2],round,2)
```

### pbi$dist - additional distance functions

```{r}
round(cor(iris[,1:4]),2)
round(as.matrix(pbi_dist(t(iris[,1:4]),method="pearson")),2)
biris=iris[,1:4]
biris=apply(biris,2,function(x) { return(x>median(x)) })
head(biris,3)
head(apply(biris,2,as.numeric),3)
biris=apply(biris,2,as.numeric)
summary(biris)
round(as.matrix(pbi_dist(t(biris),method="mc")),2)
```

### pbi$impute - impute missing values

Some  mathematical  methods like PCA require  complete data matrices. Often we
have  however  missing  values  which we need to replace with guessed  values.
Removing  all rows or  columns  with  missing  values  is often not  feasible.
Replacing the missing  values with the mean or the median of the variable is a
very  simple  but not so  reliable  option.  Better  are  methods  like  using
regression or knn-approach. Here some example how to do this.

```{r}
data(iris)
ir=as.matrix(iris[,1:4])
idx=sample(1:length(ir),5)
### introduce a few NA's for demonstration purpose
ir[idx]=NA
summary(ir)
irc=as.matrix(ir)
ir=pbi_impute(as.data.frame(ir))
summary(ir)
ir=iris
ir[1,3]=NA; ir[2,4]=NA; ir[c(1,3),5]=NA
head(ir,3)
head(pbi_impute(ir,method="rpart"),3)
irmea=pbi_impute(irc,method="mean")
irknn=pbi_impute(irc,method="knn")
irrpt=pbi_impute(as.data.frame(irc),method="rpart")
### how similar are real and impute values
cor(as.matrix(iris[,1:4])[is.na(irc)],irmea[is.na(irc)])
cor(as.matrix(iris[,1:4])[is.na(irc)],irknn[is.na(irc)])
cor(as.matrix(iris[,1:4])[is.na(irc)],irrpt[is.na(irc)])
```

## Effect size functions

Effect size  measures are often ignored by  researchers  despite the fact that
the focus of reporting should be more on the effect size than on the p-value.

The _pbi_ package provides the following effect size measures for comparing means:

- Cohen's d - `pbinf$cohensD` - comparing two means
- Eta squared -  `pbinf$etaSquared` - comparing three or more means of normally distributed data
- Epsilon squared - `pbinf$epsilonSquared` - comparing three or more means of non-normally distributed data

Here some code examples:

```{r}
rn1=rnorm(50,mean=10,sd=1)
rn2=rnorm(50,mean=12,sd=1)
rn3=rnorm(50,mean=14,sd=1)
pbi$cohensD(x=c(rn1,rn2),y=as.factor(rep(c('A','B'),each=50)))
pbi$etaSquared(x=c(rn1,rn2,rn3),y=as.factor(rep(c('A','B','C'),each=50)))
pbi$epsilonSquared(x=c(rn1,rn2,rn3),y=as.factor(rep(c('A','B','C'),each=50)))
pbi$epsilonSquared(x=c(rn1,rn2,rn3+2),y=as.factor(rep(c('A','B','C'),each=50)))
```

For contingency tables we have implemented two effect size measures, Cohen's h
for 2x2 contingency tables and Cohen's w (omega) for 2x2 or larger contingency
tables.  Here two examples:

```{r}
data(HairEyeColor)
HairEyeColor[,,'Male']
pbi$cohensW(HairEyeColor[,,'Male'])
pbi$cohensW(HairEyeColor[,,'Female'])
```

Data from New Eng J Med 329:297-303 (1993):

```{r}
azt=as.table(matrix(c(76,399,129,332), byrow=TRUE,ncol=2))
rownames(azt)=c("AZT","Placebo")
colnames(azt)=c("DiseaseProgress", "NoDiseaseProgress")
pbi$cohensW(azt)
pbi$cohensH(azt)
```

The interpretation rules for those effect size measures are due to Cohen's rule of thumb:

| measure | small | medium | large   |
|:-------:|:-----:|:------:|:-------:|
| Comparing means | |      |         |
|Cohen's d| 0.2   | 0.5    | 0.8     |
|Eta squared | 0.01   | 0.09 | 0.25  |
|Epsilon squared | 0.01 | 0.09 | 0.25|
| Continency tables |   |  |         |
|Cohen's w| 0.1   | 0.3    | 0.5     |
|Cohen's h| 0.2   | 0.5    | 0.8     |

## Reporting functions

Writing  reports is simplified  with the following  functions.  They should be
usually  embedded within the main text. In Latex we would use the Sexpr macro,
in Markdown the single backtick short R fragments.

First examples for reporting p-values  which should be given usually with the thresholds <.05, <0.01 or <.001 if significant.

```{r}
pbi$report.pval(0.06)
pbi$report.pval(t.test(rn1,rn2)$p.value)
pbi$report.pval(1/50)
pbi$report.pval(1/500)
pbi$report.pval(1/500,star=TRUE)
```

Here how to create text for confidence intervals:

```{r}
pbi$report.conf.int(t.test(rn1,rn2)$conf.int)
```

And here the report of a chisq.test:

```{r}
pbi$report.chisq.test(azt)
```

## Plotting functions

Let's look at a few plotting functions which are often just minor improvements of existing plots, such as:

### pbi$dassoc - assocplot with residual coloring

```{r fig.width=9,fig.height=6}
x = margin.table(HairEyeColor, c(1, 2))
pbi$dassoc(x)
```

The color limits are 4, 2, -2, -4 for positive  (dark blue, blue) and negative
(dark red, red)  residuals. We can see that blue eyed students have more blond
hairs than expected by chance. The dark color indicated a residual of more than +4.

```{r}
round(chisq.test(x)$residuals,2)
```
### pbi$dcorrplot - visualizing pairwise correlations

There exists a nice R package  `corrplot`  which you should use in most cases.
The function  `pbi$dcorrplot` just provides a simple alternative to this great
package. Here an example

```{r fig.width=9,fig.height=9}
data(swiss)
sw=swiss
colnames(sw)=abbreviate(colnames(swiss),6)
cr=pbi_dcorr(sw,method='spearman')
pbi_dcorrplot(cr$estimate,cex.sym=8,text.lower=TRUE,
cex.r=1.5,p.mat=cr$p.value)
```

### pbi$domainplot - plotting protein domains

This function  displays  protein domains using the expasy web service. Here an
example:

```{r}
url=pbi_domainplot(
domains=list(MYDOM1=c(100,200,2,1),MYDOM2=c(300,500,3,2)),
   ranges=list(a=c(190,500,1)),
   sites=list(a=c(150,1),b=c(250,2)),hscale=1.5,plot=FALSE)
print(url)
```

The url can be directly embedded in a Markdown document:

![ ](`r url`)

### pbi$dpairs -  improved pairs plot

The normal pairs plot only displays scatter plots per default, regardless of the data type.
The function  `pbi$dpairs`  chooses  either  boxplots,  assocplots or xy-plots
depending on the data types of the paired  variables.  Adding legends to pairs
plots is usually  difficult, the function  `pbi$dpairs.legend`  simplifies this.
Here an example:


```{r fig.width=9,fig.height=9}
data(iris)
par(omi = c(0.8, 0.4,0.4,0.4))
pbi_dpairs(iris,col.box=2:4,col.xy=rep(c(2:4),each=50), cex.diag=1.6)
pbi_dpairs.legend(levels(iris$Species),col=2:4)
```

In the upper diagonal here the effect size measures,  appropriate for the data
types are shown.

### pbi$lmplot - plotting confidence interval for regression coefficient

This plot  produces an improved  xy-plot  with  confidence  intervals  for the
regression line and for the prediction interval. Here an example:

```{r fig.width=7,fig.height=5}
c20.22=c(
  17.9, 18.3, 18.3, 18.4, 18.4, 20.2, 20.3, 21.8, 21.9,
  22.1, 23.1, 24.2, 24.4)
ins.sens=c(
  250, 220, 145, 115, 230, 200, 330, 400, 370, 260, 270,
  530, 375)
pbi_lmplot(x=c20.22,y=ins.sens,
   xlab='%C20-22 Fatty Acids',ylim=c(0,600),
   xlim=c(17,25),main='best fit',
   ylab='Insuline Sensitivity Index (mg/m^2/min)')
   
legend('bottomright',c('best fit','fit 95% CI',
  'prediction 95% CI'),lty=c(1,2,2), col=c('red','red','blue'))
```

### pbi$xyplot - improved xy-plot with correlation coefficient

This  plot is an  improved  version  of  standard  xy-plot  for two  numerical
variables.

```{r fig.width=6,fig.height=5}
pbi_xyplot(iris$Sepal.Width,iris$Sepal.Length,
     xlab="Sepal.Width",ylab="Sepal.Height",
     col=as.numeric(iris$Species)+1)
legend("bottomright",fill=2:4,legend=levels(iris$Species))
```

## File functions

There are as well two utility functions to display the content of text files:

- `pbi$file.head` - show the first lines of a file
- `pbi$file.cat` -  return a file as a long string

```{r}
pbi$file.head('tutorial.Rmd')
content=pbi$file.cat('tutorial.Rmd')
nchar(content)
head(strsplit(content,"\n")[[1]])
```

## PCA functions

Principal   component   analysis  is  a  nice  way  to  do  some  introductory
visualizations   of   multivariate   data.  The  pbi  package  prvodes  a  few
improvements on the standard PCA plots which are coming with R. In the package
are the following functions available:

- pbi$pca.biplot - plot scores and original variables
- pbi$pca.corplot - plot associations between original variables and new components
- pbi$pca.pairs   - pairs plot for PCA 
- pbi$pca.plot    - improved screeplot
- pbi$pca.toData  - recalculate original data from PCA data
- pbi$pca.variances - display component variances
- pbi$pca.varplot  - plot component variances

Here some code examples for these functions.

### pbi$pca.biplot - display scores and original variables

```{r fig.width=9,fig.height=9}
data(iris)
par(mfrow=c(2,2),mai=rep(0.3,4))
pci=prcomp(iris[,1:4],scale=TRUE)
pbi_pca.biplot(pci,col=rep(2:4,each=50),ellipse=TRUE,ell.fill=TRUE,
   arrow.fac=2.3,arrows=TRUE)
legend('topright',pch=19,col=2:4,levels(iris$Species))
# just a score plot
pbi_pca.biplot(pci,col=rep(2:4,each=50),ellipse=TRUE,ell.fill=TRUE,
   arrow.fac=2.3,arrows=FALSE)
pbi_pca.biplot(pci,col=rep(2:4,each=50),ellipse=FALSE,arrow.fac=2.3,arrows=FALSE)
pbi_pca.biplot(pci,pcs=c('PC1','PC3'),col=rep(2:4,each=50),
   ellipse=FALSE,arrow.fac=2.3,arrows=FALSE)
```

Here some alternative representations:

```{r fig.width=9,fig.height=4.5}
data(iris)
par(mfrow=c(1,2),mai=rep(0.4,4))
data(swiss)
col=c(2,4)[as.numeric(cut(swiss$Catholic,breaks=c(0,20,100)))]
pcs=prcomp(swiss,scale=TRUE)
pbi_pca.biplot(pcs,arrow.fac=2,grid=FALSE,
   col=col,ellipse=TRUE,text=substr(rownames(swiss),1,3))
pbi_pca.biplot(pcs,arrow.fac=2,grid=TRUE,
   col=col,text=substr(rownames(swiss),1,3),scale=asinh,arrows=FALSE)
```

### pbi$pca.corplot - display correlations between original variables and new PC's

```{r fig.width=9,fig.height=4.5}
par(mfrow=c(1,2),mai=c(0.7,0.7,0.5,0.1))
library(cluster)
data(votes.repub)
pca=prcomp(t(na.omit(votes.repub)))
pbi_pca.corplot(pca)
data(swiss)
pca=prcomp(swiss,scale.=TRUE)
pbi_pca.corplot(pca)
```

### pbi$pca.pairs - pairs plot for a PCA

```{r fig.width=9,fig.height=9}
data(iris)
pci=prcomp(iris[,1:4],scale=TRUE)
pbi_pca.pairs(pci,pch=15,groups=iris[,5],
legend=TRUE,oma=c(5,4,4,4),col=as.numeric(iris[,5])+1)
```

### pbi$pca.plot - improved scree plot

```{r fig.width=9,fig.height=4.5}
data(iris)
par(mfrow=c(1,2))
pcai=prcomp(iris[,1:4],scale=TRUE)
pbi_pca.plot(pcai)
pbi_pca.plot(pcai,type="scree",legend=FALSE)
```

### pbi$pca.toData - backtransform PCA into original data

```{r}
pca=prcomp(iris[,1:4])
head(iris[,1:4])
head(pbi_pca.toData(pca))
### remove effect of first component
pca$rotation[,1]=0
head(pbi_pca.toData(pca))
```

### pbi$pca.varplot - PCA variance plot

Here an example:

```{r fig.width=9,fig.height=5}
data(USArrests)
pbi_pca.varplot(prcomp(USArrests,scale=TRUE),cex.sym=8)
data(swiss)
pca=prcomp(swiss,scale=TRUE)
round(pbi_pca.variances(pca),3)
pbi_pca.varplot(pca,cex.sym=5,cex.var=0.7,cex.lab=1)
```

## Sequence related functions
